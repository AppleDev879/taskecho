import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:interview_todos/models/openai_response.dart';
import 'package:interview_todos/services/local_notifications.dart';
import 'package:isar/isar.dart';

import '../models/todo.dart';
import 'isar_provider.dart';

/// A provider that manages the list of todos and their state.
///
/// This provider handles all CRUD operations for todos and manages their state
/// using Riverpod's StateNotifier. It also integrates with Isar for persistence
/// and handles local notifications for todos with due dates.
final todoListProvider = StateNotifierProvider<TodoNotifier, AsyncValue<List<Todo>>>((ref) {
  final isarAsync = ref.watch(isarProvider);

  return isarAsync.when(
    data: (isar) => TodoNotifier(isar),
    loading: () => TodoNotifier(null),
    error: (e, st) => throw e,
  );
}, dependencies: [isarProvider]);

/// Manages the state and business logic for todos in the application.
///
/// This class handles all operations related to todos including loading, adding,
/// updating, and deleting todos. It ensures that the UI state is kept in sync
/// with the persisted data in the Isar database.
class TodoNotifier extends StateNotifier<AsyncValue<List<Todo>>> {
  final Isar? isar;

  /// Creates a new [TodoNotifier] with an optional [Isar] instance.
  ///
  /// If [isar] is provided, it will immediately load todos from the database.
  /// If [isar] is null, the state will be set to loading until [loadTodos] is called.
  TodoNotifier(this.isar) : super(const AsyncValue.loading()) {
    if (isar != null) {
      loadTodos();
    }
  }

  /// Loads all todos from the database and updates the state.
  ///
  /// This method should be called whenever the list of todos needs to be refreshed
  /// from the database. It handles the loading state and error states automatically.
  Future<void> loadTodos() async {
    if (isar == null) return;
    try {
      state = const AsyncValue.loading();
      final todos = await isar!.todos.where().findAll();
      state = AsyncValue.data(todos);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  /// Adds a new todo with the given [title] and optional [category].
  ///
  /// The new todo will be persisted to the database and the UI will be updated
  /// to reflect the change. The todo will be created with [isDone] set to false.
  /// If no category is provided, it defaults to [TodoCategory.personal].
  Future<void> addTodo({required String title, TodoCategory? category}) async {
    if (isar == null) return;
    try {
      final todo = Todo(
        title: title,
        isDone: false,
        category: category ?? TodoCategory.personal,
      );
      await isar!.writeTxn(() async {
        await isar!.todos.put(todo);
      });
      await loadTodos();
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Adds multiple todos from a list of [OpenAIResponse] objects.
  ///
  /// This is typically used to process and add todos that were generated by
  /// the AI. Each response is converted to a [Todo] and scheduled for
  /// notification if it has a due date.
  Future<void> addTodosFromOpenAI({required List<OpenAIResponse> responses}) async {
    if (isar == null) return;
    try {
      final todos = responses
          .map(
            (response) => Todo(
              title: response.title,
              description: response.description,
              isDone: false,
              category: response.category == 'personal' ? TodoCategory.personal : TodoCategory.work,
              dueDate: DateTime.tryParse(response.dateTime),
            ),
          )
          .toList();

      await isar!.writeTxn<List<Id>>(() async {
        return isar!.todos.putAll(todos);
      });

      // Schedule notifications for todos with due dates after now
      final newTodosWithDueDates = todos
          .where((todo) => todo.dueDate != null && todo.dueDate!.isAfter(DateTime.now()))
          .toList();
      for (final todo in newTodosWithDueDates) {
        LocalNotifications.scheduleNotification(
          id: todo.id,
          body: todo.title,
          scheduledDate: todo.dueDate!,
        );
      }
      await loadTodos();
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Toggles the completion status of a todo.
  ///
  /// Updates both the UI state and the database to reflect the new completion
  /// status. This is an idempotent operation.
  ///
  /// If the database operation fails, it will set the state to an error state
  /// with the error message and stack trace.
  Future<void> toggleTodo(Todo todo) async {
    if (isar == null) return;
    try {
      await isar!.writeTxn(() async {
        todo.isDone = !todo.isDone;
        await isar!.todos.put(todo);
      });
      LocalNotifications.cancelNotification(todo.id);
      await loadTodos();
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Updates a todo with the given [updated] todo.
  ///
  /// Handles special cases like due date changes that require notification
  /// updates. The method ensures that the database and UI state remain in sync.
  /// If the todo's due date changes, any existing notification will be updated.
  ///
  /// Throws a [StateError] if the todo to update is not found in the current state.
  Future<void> updateTodo(
    Id id, {
    String? title,
    String? description,
    bool? isDone,
    TodoCategory? category,
    DateTime? dueDate,
  }) async {
    if (isar == null) return;
    
    // Find the existing todo to compare changes
    final todo = state.valueOrNull?.firstWhere((t) => t.id == id,
      orElse: () => throw StateError('Todo not found'),
    );

    todo?.category = category ?? todo.category;
    todo?.description = description ?? todo.description;
    todo?.isDone = isDone ?? todo.isDone;
    todo?.title = title ?? todo.title;
    
    try {
      // Only proceed if the date actually changed
      if (todo != null && dueDate != todo.dueDate) {
        // Update the due date
        todo.dueDate = dueDate;
        // Cancel any existing notification for the old due date
        await LocalNotifications.cancelNotification(id);

        // Schedule a new notification if the new date is in the future
        if (dueDate != null && dueDate.isAfter(DateTime.now())) {
          await LocalNotifications.scheduleNotification(
            id: id, body: todo.title, scheduledDate: dueDate,
          );
        }
      }
      
      // Update the todo in the database
      await isar!.writeTxn(() => isar!.todos.put(todo!));
      
      // Refresh the list to ensure UI consistency
      await loadTodos();
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Deletes a todo by its [id].
  ///
  /// Performs an optimistic update by immediately removing the todo from the UI
  /// state before attempting to delete it from the database. If the database
  /// operation fails, the original state is restored.
  ///
  /// Also cancels any pending notifications associated with the todo.
  Future<void> deleteTodo(int id) async {
    if (isar == null) return;
    
    // Save the current state for rollback if needed
    final previousState = state;
    
    try {
      // Optimistically update the UI by filtering out the deleted todo
      state = AsyncValue.data([
        for (final todo in state.valueOrNull ?? [])
          if (todo.id != id) todo,
      ]);
      
      // Perform the database operation
      await isar!.writeTxn(() => isar!.todos.delete(id));
      
      // Cancel any associated notification
      await LocalNotifications.cancelNotification(id);
    } catch (e, st) {
      // Rollback on error to maintain consistency
      state = previousState;
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}
